<link rel="import" href="refinery-select-popup.html" />

<dom-module id="parcel-map">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>

  </template>
  <script>
    Polymer({
      is: 'parcel-map',

      ready : function() {
        // current modes are 'set' (set refinery location) or 'select' which is select parcel
        this.mode = 'set';
        this.radius = 40000;
        this.rand = 0.8;

        $(window).on('resize', this.onResize.bind(this));

        this.popup = document.createElement('refinery-select-popup');
        document.body.appendChild(this.popup);

        this.parcelPopup = document.createElement('parcel-info-popup');
        document.body.appendChild(this.parcelPopup);

        DSSDK.app.setOnCompleteListener(this.onSelectedUpdated.bind(this));
        DSSDK.datastore.on('parcels-update-end', this.onParcelsLoaded.bind(this));
      },

      onShow : function() {
        if( this.map ) {
          this.map.invalidateSize();
        }
      },

      setMenu : function(ele) {
        this.menu = ele;
        this.menu.setMode(this.mode);
      },

      attached : function() {
        if( !this.map ) {
          this.onResize();
          this.map = L.map(this).setView([44, -121], 6);
          this.map.on('click', this.onClick.bind(this));
          L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
              attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
          }).addTo(this.map);

          var layer = L.esri.dynamicMapLayer({
            url: 'https://conifer.gis.washington.edu/arcgis/rest/services/AHBNW/AHBNW_20151009_parcel_featureAccess/MapServer',
            opacity: 0.5
          }).addTo(this.map);

          L.control.layers({}, {Parcels: layer}).addTo(this.map);

          this.canvasLayer = new L.CanvasGeojsonLayer({
            /*,onMouseOver : function(features) {
              //markerSelector.hover(features);
              //updateMouse(markerLayer._container, markerLayer.intersectList);
            }.bind(this)
            onMouseOut : function(features) {
              markerSelector.nohover(features);
              updateMouse(markerLayer._container, markerLayer.intersectList);
            }.bind(this),*/
            onClick : this.onFeaturesClicked.bind(this)
          });
          this.canvasLayer.addTo(this.map);
        }
      },

      onResize : function() {
        this.style.height = ($(window).height()-50)+'px';
      },

      onFeaturesClicked : function(features) {
        if( this.mode === 'set' ) return;

        for( var i = 0; i < features.length; i++ ) {
          if( features[i].properties.ucd ) {
            this.parcelPopup.show(features[i]);
            return;
          }
        }
      },

      onClick : function(e) {
        if( this.mode != 'set' ) {
          return;
        }

        this.ll = e.latlng;
        this.popup.show(this.ll.lat, this.ll.lng);
      },

      // TODO: bind to this
      // DSSDK.datastore.on('transportation-updated', this.renderRoads);
      onSelectedUpdated : function() {
        for( var i = this.canvasLayer.features.length-1; i >= 0; i-- ) {
          var geo = this.canvasLayer.features[i].geojson.geometry;
          if( geo.type === 'LineString' ){
            this.canvasLayer.features.splice(i, 1);
          }
        }

        // actually hide the parcel at the canvas layer... thus no geometry recalc
        this.canvasLayer.features.forEach(function(clFeature){
          if( DSSDK.datastore.selectedParcels.indexOf(clFeature.geojson) === -1 ) {
            clFeature.visible = false;
          } else {
            clFeature.visible = true;
          }
        });

        this.currentNetwork = {};
        DSSDK.datastore.parcels.forEach(function(parcel){
          if( DSSDK.datastore.selectedParcels.indexOf(parcel) > -1 ) {
            parcel.properties.ucd.render.selected = true;
          } else {
            parcel.properties.ucd.render.selected = false;
            return;
          }

          if( parcel.properties.ucd.transportation.properties.error ) {
            return;
          }

          // set the current network
          var path = parcel.properties.ucd.transportation.properties.path;
          path.forEach(function(id){
            if( this.currentNetwork[id] === undefined ) {
              this.currentNetwork[id] = 1;
            } else {
              this.currentNetwork[id]++;
            }
          }.bind(this));

          // render a line for shortest path vertex to feature centroid
          var f = DSSDK.datastore.network[path[0]];
          var feature = {
            type : 'Feature',
            geometry : {
              type : 'LineString',
              coordinates : [
                f.geometry.coordinates[0],
                parcel.properties.ucd.center
              ]
            },
            properties : {
              type : 'start'
            }
          };

          if( feature.geometry.coordinates[0] === undefined || feature.geometry.coordinates[1] === undefined ) {
            console.log(feature);
            return;
          }

          this.canvasLayer.addFeature({
            geojson : feature,
            render : this.lineRenderer.bind(this)
          });
        }.bind(this));

        for( var id in this.currentNetwork ) {
          var feature = DSSDK.datastore.network[id];
          if( feature.properties.error ) {
            return;
          }
          this.canvasLayer.addFeature({
            geojson : feature,
            render : this.lineRenderer.bind(this)
          });
        }

        this.menu.updateSelected();
        this.canvasLayer.render();
      },

      onParcelsLoaded : function() {
        this.canvasLayer.features = [];

        DSSDK.datastore.parcels.forEach(function(parcel){
          this.canvasLayer.addFeature(this.canvasLayerFeature(parcel));
        }.bind(this));

        this.canvasLayer.render();

        if( DSSDK.datastore.parcels.length > 0 ) {
          this.mode = 'select';
          this.menu.setMode(this.mode);
        }

        this.menu.updateSelected();
      },

      onParcelQueryUpdate : function(percent) {
        this.popup.updateStatus(percent);
      },

      canvasLayerFeature : function(parcel) {
        if( !parcel.properties.ucd.render ) {
          parcel.properties.ucd.render = {};
        }

        return {
          geojson : parcel,
          render : this.polyRenderer.bind(this),
          visible : false
        };
      },

      polyRenderer : function(ctx, xyPoints, map, feature) {
        var render = feature.geojson.properties.ucd.render;
        if( !render.selected ) {
          console.log(feature.geojson);
          return;
        }

        if( feature.geojson.geometry.type === 'MultiPolygon' ) {
          xyPoints.forEach(function(points){
            this.drawPolygon(ctx, points, feature);
          }.bind(this));
        } else {
          this.drawPolygon(ctx, xyPoints, feature);
        }
      },

      drawPolygon : function(ctx, xyPoints, feature) {
        var point;
        if( xyPoints.length <= 1 ) {
          console.log('1 point path!');
          return;
        }

        ctx.beginPath();

        point = xyPoints[0];
        ctx.moveTo(point.x, point.y);
        for( var i = 1; i < xyPoints.length; i++ ) {
          ctx.lineTo(xyPoints[i].x, xyPoints[i].y);
        }
        ctx.lineTo(xyPoints[0].x, xyPoints[0].y);

        if( feature.geojson.properties.ucd.transportation.properties.error ) {
          ctx.strokeStyle = 'rgba(255,0,0,.6)';
        } else {
          ctx.strokeStyle = 'rgba(0,0,255,.6)';
        }

        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.fillStyle = 'rgba(255,255,255,.6)';
        ctx.fill();
      },

      lineRenderer : function(ctx, xyPoints, map, feature) {
        var point, last;
        if( xyPoints.length <= 1 ) return;

        ctx.beginPath();

        point = xyPoints[0];
        ctx.moveTo(point.x, point.y);
        last = point;
        for( var i = 1; i < xyPoints.length; i++ ) {
          point = xyPoints[i];
          if( point.x === last.x && point.y === last.y ) {
            continue;
          }
          ctx.lineTo(point.x, point.y);
          last = point;
        }

        if( feature.geojson.properties.type === 'start') {
          ctx.strokeStyle = 'rgba(100,100,100,.6)';
        } else {
          var use = DSSDK.datastore.networkUse[feature.geojson.properties.id];
          var p = use / DSSDK.datastore.maxNetworkUse;

          if( p < 0.333 ) {
            ctx.strokeStyle = 'rgba(0,255,0,.6)';
          } else if ( p > 0.666 ) {
            ctx.strokeStyle = 'rgba(255,0,0,.6)';
          } else {
            ctx.strokeStyle = 'rgba(255,255,0,.6';
          }
        }

        ctx.lineWidth = 4;
        ctx.stroke();
      },

      setMode : function(mode) {
        this.mode = mode;
      }
    });
  </script>
</dom-module>
